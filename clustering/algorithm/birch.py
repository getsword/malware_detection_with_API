from sklearn.cluster import Birch
import joblib
from sklearn.datasets import make_blobs
import random


def save_BIRCH(model, model_path):
    joblib.dump(model, model_path)


def load_BIRCH(model_path):
    return joblib.load(model_path)


class BIRCH():
    """
    threshold: The radius of the subcluster obtained by merging a new sample and the closest subcluster should be lesser than the threshold. Otherwise a new subcluster is started. Setting this value to be very low promotes splitting and vice-versa.
    branching_factor: Maximum number of CF subclusters in each node.
    n_clusters: Number of clusters after the final clustering step, which treats the subclusters from the leaves as new samples.
    computer_labels: Whether or not to compute labels for each fit.
    copy: Whether or not to make a copy of the given data. If set to False, the initial data will be overwritten.
    """

    def __init__(self, threshold=0.5,branching_factor=50,n_clusters=3,compute_labels=True,copy=True):
        self.model = Birch(threshold=threshold,branching_factor=branching_factor,n_clusters=n_clusters,compute_labels=compute_labels,copy=copy)

    def fit(self, x):
        self.model.fit(x)

    def predict(self, x):
        return self.model.predict(x)


if __name__ == "__main__":
    X,y=make_blobs(n_samples=800,n_features=5,centers=3,random_state=2023)
    idx=[i for i in range(800)]
    random.shuffle(idx)
    model=BIRCH(3)
    model.fit(X[idx])

    save_BIRCH(model,'birch.joblib')

    new_model=load_BIRCH('birch.joblib')
    pre=new_model.predict(X[idx[600:]])
    print(y[idx[600:]]==pre)
