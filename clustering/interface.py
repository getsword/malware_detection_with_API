import numpy as np
from algorithm.kmean import K_Means,save_KMeans,load_KMeans
from preprocess import Preprocess_Argument,mkdir_all
import pathlib
import os
import json


CLUSTER_K_MEANS=3
NAME="_CLUSTER_3"

def train():
    # 预处理
    p = Preprocess_Argument("../data/all", "preprocess_output"+NAME+"/", "tmp"+NAME+"/", "preprocess_model"+NAME+"/")
    p.train()
    # 需要把pandas转化为numpy的数组
    output_list = []
    map_list=[]
    for i in os.listdir(p.output_path):
        if 'map' in i:
            map_list.append(p.output_path.joinpath(i))
        else:
            output_list.append(p.output_path.joinpath(i))

    with open("tmp" + NAME + "/function_index.json", 'r', encoding='utf-8') as f:
        function_index = json.loads(f.read())

    exist_model=[]
    pred_result={}
    rr=-1
    for i in output_list:
        rr+=1
        name = i.name[:i.name.find('.')]

        # function_index 确定哪些是train数据
        train_index=[]
        for idx in range(len(function_index['function'][name])):
            if function_index['function'][name][idx][2]==1:
                train_index.append(idx)

        print(str(rr)+" "+str(i)+" clustering...")
        output_df=p.read_output(i)
        data, label = output_df.iloc[train_index, :-1], output_df.iloc[train_index, -1]
        arrays = data.values
        labels = label.values

        if np.size(arrays,axis=0)<=CLUSTER_K_MEANS:
            continue

        model=K_Means(CLUSTER_K_MEANS,random_state=2023)
        model.fit(arrays)
        pred=model.predict(arrays)

        # 统计一下聚成的类和标签的情况
        cls2idx={}
        cls2label={}
        for cls,label in zip(pred,labels):
            if cls not in cls2idx.keys():
                cls2idx[cls]=[]
            cls2idx[cls].append(label)

        sort_cls=sorted(cls2idx.items(),key=lambda x:len([j==1 for j in x[1]])/(len(x[1])+1)) # 升序
        for o,j in enumerate(sort_cls):
            cls2label[str(j[0])]=o
        # label值越大，越危险

        # 要保存K_Means模型
        # 以及 聚类后的类和标签的映射
        # 准备训练K_Means
        model_root=pathlib.Path('model'+NAME+'/')
        mkdir_all(model_root)
        exist_model.append(name)
        model_path=model_root.joinpath(name+'.joblib')
        save_KMeans(model,model_path)
        map_path=model_root.joinpath(name+'.json')
        with open(map_path,'w',encoding='utf-8') as f:
            f.write(json.dumps(cls2label))

        # 聚类 K-means模型路径： model/{函数名}.joblib
        # 聚类结果映射标签的导出字典的路径：model/{函数名}.joblib

        data, label = output_df.iloc[:, :-1], output_df.iloc[:, -1]
        arrays = data.values
        pred=model.predict(arrays)

        pred_label=[cls2label[str(i)] for i in pred]
        pred_result[name]=pred_label

    exist_model_path=model_root.joinpath("exist_model.json")
    with open(exist_model_path,'w',encoding='utf-8') as f:
        f.write(json.dumps(exist_model,ensure_ascii=False))

    return pred_result


# 针对某个函数得到标签
def test_one(function_str,model="",cls2label=""):
    p = Preprocess_Argument("../data/test", "preprocess_output"+NAME+"/", "tmp"+NAME+"/", "preprocess_model"+NAME+"/")
    function_name,data=p.test(function_str)

    if data:
        arrays=np.array(data)

        if model=="" and cls2label=="":
            # 载入模型进行预测
            model_root = pathlib.Path('model'+NAME+'/')
            name = function_name
            model_path = model_root.joinpath(name + '.joblib')
            if not model_path.exists():
                return -1
            model = load_KMeans(model_path)

            map_path = model_root.joinpath(name + '.json')
            with open(map_path, 'r', encoding='utf-8') as f:
                cls2label = json.loads(f.read())

        pred = model.predict(arrays)

        labels = [cls2label[str(i)] for i in pred]

        return labels[0]
    else:
        return -1

def main():
    # train()
    # print(test_one("CopyFileExW(KMwW.exe, C:\\classified.doc.exe)"))
    # print(test_one("CopyFileExW(C:\\program\\1.exe, C:\\WINDOWS\\system32\\DC++ Share\\AliWorkbench.exe"))
    print(test_one('CopyFileExW(㈸㠱㤱㘹, C:\\classified.doc.exe)'))

if __name__=="__main__":
    main()
